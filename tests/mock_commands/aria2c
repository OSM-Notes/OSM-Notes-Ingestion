#!/bin/bash

# Mock aria2c command for testing
# Author: Andres Gomez (AngocA)
# Version: 2025-11-24

# Function to create mock files
create_mock_file() {
 local url="$1"
 local output_file="$2"
 local output_dir="$3"
 
 # Build full path if directory is specified
 if [[ -n "$output_dir" && -n "$output_file" ]]; then
   output_file="${output_dir}/${output_file}"
 elif [[ -n "$output_dir" ]]; then
   output_file="${output_dir}/$(basename "$url")"
 fi
 
 # Extract filename from URL if no output file specified
 if [[ -z "$output_file" ]]; then
   output_file=$(basename "$url")
 fi
 
 # Ensure directory exists
 local file_dir
 file_dir=$(dirname "$output_file")
 if [[ -n "$file_dir" && "$file_dir" != "." ]]; then
   mkdir -p "$file_dir"
 fi
 
 # Create mock content based on URL
 if [[ "$url" == *".xml" ]]; then
   cat > "$output_file" << 'INNER_EOF'
<?xml version="1.0" encoding="UTF-8"?>
<osm-notes>
 <note id="6000000" lat="40.7128" lon="-74.0060" created_at="2023-01-01T00:00:00Z">
  <comment action="opened" timestamp="2023-01-01T00:00:00Z" uid="12345" user="testuser">Test note</comment>
 </note>
 <note id="6000001" lat="40.7129" lon="-74.0061" created_at="2023-01-01T01:00:00Z">
  <comment action="opened" timestamp="2023-01-01T01:00:00Z" uid="12346" user="testuser2">Another test note</comment>
 </note>
</osm-notes>
INNER_EOF
 elif [[ "$url" == *".bz2" ]] || [[ "$url" == *".osn.bz2" ]]; then
   # Use pre-prepared fixture file instead of generating on the fly
   # This ensures the file is always valid and avoids PATH resolution issues
   # Find the fixture file by trying multiple possible paths
   local fixture_file=""
   
   # Function to find project root from a starting directory
   find_project_root() {
     local start_dir="$1"
     local search_dir="${start_dir}"
     while [[ "${search_dir}" != "/" ]]; do
       if [[ -d "${search_dir}/tests" ]] && [[ -d "${search_dir}/tests/fixtures" ]] && [[ -f "${search_dir}/tests/fixtures/planet-notes-latest.osn.bz2" ]]; then
         echo "${search_dir}"
         return 0
       fi
       search_dir=$(dirname "${search_dir}")
     done
     return 1
   }
   
   # Try multiple starting points to find the project root
   local project_root=""
   
   # 1. Try from SCRIPT_BASE_DIRECTORY environment variable (if set)
   if [[ -n "${SCRIPT_BASE_DIRECTORY:-}" ]] && [[ -d "${SCRIPT_BASE_DIRECTORY}" ]]; then
     project_root=$(find_project_root "${SCRIPT_BASE_DIRECTORY}" 2>/dev/null || true)
   fi
   
   # 2. Try from current working directory (PWD)
   if [[ -z "${project_root}" ]]; then
     project_root=$(find_project_root "${PWD}" 2>/dev/null || true)
   fi
   
   # 3. Try from the directory where this script is located
   if [[ -z "${project_root}" ]]; then
     local script_dir
     script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd 2>/dev/null || echo "")"
     if [[ -n "${script_dir}" ]]; then
       project_root=$(find_project_root "${script_dir}" 2>/dev/null || true)
     fi
   fi
   
   # 4. Try absolute path (hardcoded fallback)
   if [[ -z "${project_root}" ]] && [[ -f "/home/angoca/github/OSM-Notes-Ingestion/tests/fixtures/planet-notes-latest.osn.bz2" ]]; then
     project_root="/home/angoca/github/OSM-Notes-Ingestion"
   fi
   
   # Try multiple possible paths for the fixture file
   # Priority: 1) realistic fixture (if generated), 2) default fixture
   for possible_path in "${project_root}/tests/fixtures/planet-notes-latest.osn.bz2" "/home/angoca/github/OSM-Notes-Ingestion/tests/fixtures/planet-notes-latest.osn.bz2"; do
     if [[ -n "${possible_path}" ]] && [[ -f "${possible_path}" ]]; then
       # Check file size - if it's larger than 1KB, it's likely the realistic fixture
       local file_size
       file_size=$(stat -f%z "${possible_path}" 2>/dev/null || stat -c%s "${possible_path}" 2>/dev/null || echo "0")
       if [[ "${file_size}" -gt 1024 ]]; then
         fixture_file="${possible_path}"
         break
       elif [[ -z "${fixture_file}" ]]; then
         # Keep first match as fallback
         fixture_file="${possible_path}"
       fi
     fi
   done
   
   # Check if fixture file exists
   if [[ -n "${fixture_file}" ]] && [[ -f "${fixture_file}" ]]; then
     # Copy the pre-prepared fixture file
     cp "${fixture_file}" "$output_file" 2>/dev/null
     local copy_exit=$?
     if [[ $copy_exit -ne 0 ]]; then
       echo "Error: Failed to copy fixture file from ${fixture_file}" >&2
       exit 1
     fi
     # Verify the copied file is actually a bzip2 file
     if ! file "$output_file" 2>/dev/null | grep -q "bzip2"; then
       echo "Error: Copied file is not a valid bzip2 file" >&2
       rm -f "$output_file" 2>/dev/null || true
       exit 1
     fi
   else
     # Fallback: Create a minimal valid bzip2 file if fixture not found
     # Create a simple XML content and compress it with bzip2
     # Use ID greater than 6 million to avoid conflicts with real API notes (< 5 million)
     if command -v bzip2 >/dev/null 2>&1; then
       cat > "${output_file}.tmp" << 'BZIP2_EOF'
<?xml version="1.0" encoding="UTF-8"?>
<osm-notes>
 <note id="6000005" lat="40.7128" lon="-74.0060" created_at="2023-01-01T00:00:00Z">
  <comment action="opened" timestamp="2023-01-01T00:00:00Z" uid="12345" user="testuser">Mock bzip2 test note</comment>
 </note>
</osm-notes>
BZIP2_EOF
       bzip2 -c "${output_file}.tmp" > "$output_file" 2>/dev/null
       rm -f "${output_file}.tmp" 2>/dev/null || true
       # Verify the file was created successfully
       if [[ ! -f "$output_file" ]] || [[ ! -s "$output_file" ]]; then
         echo "Error: Failed to create bzip2 file" >&2
         exit 1
       fi
     else
       # Last resort: create a file that looks like bzip2 (magic bytes)
       # This is not a valid bzip2 but will pass basic file checks
       printf '\x42\x5a\x68' > "$output_file"
       echo "Mock bzip2 content" >> "$output_file"
     fi
   fi
 else
   echo "Mock content for $url" > "$output_file"
 fi
 
 echo "Mock file created: $output_file"
}

# Parse arguments
ARGS=()
OUTPUT_FILE=""
OUTPUT_DIR=""
QUIET=false

while [[ $# -gt 0 ]]; do
 case $1 in
  -d)
   OUTPUT_DIR="$2"
   shift 2
   ;;
  -o)
   OUTPUT_FILE="$2"
   shift 2
   ;;
  -x)
   # Number of connections (ignore)
   shift 2
   ;;
  -q)
   QUIET=true
   shift
   ;;
  --version)
   echo "aria2c version 1.36.0"
   exit 0
   ;;
  -*)
   # Skip other options
   shift
   ;;
  *)
   ARGS+=("$1")
   shift
   ;;
 esac
done

# Get URL from arguments
URL="${ARGS[0]:-}"

if [[ -z "$URL" ]]; then
 echo "Usage: aria2c [OPTIONS] URL" >&2
 exit 1
fi

# Create mock file
create_mock_file "$URL" "$OUTPUT_FILE" "$OUTPUT_DIR"

# Simulate download completion
if [[ "$QUIET" != true ]]; then
 final_name=""
 if [[ -n "$OUTPUT_DIR" && -n "$OUTPUT_FILE" ]]; then
   final_name="${OUTPUT_DIR}/${OUTPUT_FILE}"
 elif [[ -n "$OUTPUT_DIR" ]]; then
   final_name="${OUTPUT_DIR}/$(basename "$URL")"
 elif [[ -n "$OUTPUT_FILE" ]]; then
   final_name="$OUTPUT_FILE"
 else
   final_name=$(basename "$URL")
 fi
 echo "Download completed: $final_name"
fi

exit 0
