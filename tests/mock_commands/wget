#!/bin/bash

# Mock wget command for testing
# Author: Andres Gomez (AngocA)
# Version: 2025-11-12

# Function to create mock files
create_mock_file() {
 local url="$1"
 local output_file="$2"
 local post_file="${3:-}"
 
 # Extract filename from URL if no output file specified
 if [[ -z "$output_file" ]]; then
   output_file=$(basename "$url")
 fi
 
 # Try to resolve a fixture file from URL first
 local script_dir
 script_dir=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
 local fixtures_dir
 # Use MOCK_FIXTURES_DIR if set, otherwise try to find fixtures relative to script
 # If script is in /tmp (mock environment), use SCRIPT_BASE_DIRECTORY or PROJECT_ROOT
 if [[ -n "${MOCK_FIXTURES_DIR:-}" ]]; then
   fixtures_dir="${MOCK_FIXTURES_DIR}"
 elif [[ -n "${SCRIPT_BASE_DIRECTORY:-}" ]]; then
   fixtures_dir="${SCRIPT_BASE_DIRECTORY}/tests/fixtures/command/extra"
 elif [[ -n "${PROJECT_ROOT:-}" ]]; then
   fixtures_dir="${PROJECT_ROOT}/tests/fixtures/command/extra"
 elif [[ "$script_dir" == /tmp/* ]]; then
   # If running from /tmp, try to find project root from common paths
   if [[ -d "/home/${USER}/github/OSM-Notes-Ingestion/tests/fixtures/command/extra" ]]; then
     fixtures_dir="/home/${USER}/github/OSM-Notes-Ingestion/tests/fixtures/command/extra"
   else
     fixtures_dir="${script_dir}/../fixtures/command/extra"
   fi
 else
   fixtures_dir="${script_dir}/../fixtures/command/extra"
 fi
 local candidate=""
 
 # If POST file is provided, try to extract relation ID from Overpass query
 if [[ -n "$post_file" && -f "$post_file" ]]; then
   local query_content
   query_content=$(cat "$post_file" 2>/dev/null || echo "")
   
   # Extract relation ID from Overpass query: rel(12345) or relation(12345)
   if [[ "$query_content" =~ rel\(([0-9]+)\) ]] || [[ "$query_content" =~ relation\(([0-9]+)\) ]]; then
     local relation_id="${BASH_REMATCH[1]}"
     candidate="${fixtures_dir}/${relation_id}.json"
     
     if [[ -f "$candidate" ]]; then
       cp -f "$candidate" "$output_file"
       echo "Mock file created from POST query (relation ID: ${relation_id}): $output_file"
       return 0
     else
       # Create a minimal valid Overpass JSON response if fixture doesn't exist
       # Include basic geometry (a simple square) so it can be converted to GeoJSON
       cat > "$output_file" << EOF
{
  "version": 0.6,
  "generator": "Mock Overpass API",
  "osm3s": {
    "timestamp_osm_base": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
    "copyright": "Mock data for testing"
  },
  "elements": [
    {
      "type": "node",
      "id": $((relation_id * 1000 + 1)),
      "lat": 0.0,
      "lon": 0.0
    },
    {
      "type": "node",
      "id": $((relation_id * 1000 + 2)),
      "lat": 0.0,
      "lon": 1.0
    },
    {
      "type": "node",
      "id": $((relation_id * 1000 + 3)),
      "lat": 1.0,
      "lon": 1.0
    },
    {
      "type": "node",
      "id": $((relation_id * 1000 + 4)),
      "lat": 1.0,
      "lon": 0.0
    },
    {
      "type": "way",
      "id": $((relation_id * 1000 + 10)),
      "nodes": [$((relation_id * 1000 + 1)), $((relation_id * 1000 + 2)), $((relation_id * 1000 + 3)), $((relation_id * 1000 + 4)), $((relation_id * 1000 + 1))],
      "tags": {
        "boundary": "administrative"
      }
    },
    {
      "type": "relation",
      "id": ${relation_id},
      "members": [
        {
          "type": "way",
          "ref": $((relation_id * 1000 + 10)),
          "role": "outer"
        }
      ],
      "tags": {
        "name": "Mock Country ${relation_id}",
        "name:en": "Mock Country ${relation_id}",
        "admin_level": "2",
        "boundary": "administrative",
        "type": "boundary"
      }
    }
  ]
}
EOF
       echo "Mock file created (minimal JSON for relation ID: ${relation_id}): $output_file"
       return 0
     fi
   fi
   
   # Check if POST file contains countries or maritimes query
   # Countries query: [out:csv(::id)] with admin_level="2" and boundary="administrative"
   # Maritimes query: [out:csv(::id)] with border_type
   # Note: The query may have admin_level="2" (with quotes) or admin_level=2 (without quotes)
   if [[ "$query_content" == *"out:csv"* ]] && [[ "$query_content" == *"admin_level"* ]] && [[ "$query_content" == *"2"* ]] && [[ "$query_content" == *"boundary"* ]] && [[ "$query_content" == *"administrative"* ]]; then
     candidate="${fixtures_dir}/countries"
     if [[ -f "$candidate" ]]; then
       # Overpass CSV format has a header line, but our fixture doesn't
       # Add header line to match Overpass format, then append fixture content
       echo "@id" > "$output_file"
       cat "$candidate" >> "$output_file"
       echo "Mock file created from POST query (countries CSV): $output_file"
       return 0
     fi
   fi
   
   if [[ "$query_content" == *"out:csv"* ]] && [[ "$query_content" == *"border_type"* ]]; then
     candidate="${fixtures_dir}/maritimes"
     if [[ -f "$candidate" ]]; then
       # Overpass CSV format has a header line, but our fixture doesn't
       # Add header line to match Overpass format, then append fixture content
       echo "@id" > "$output_file" 2>&1
       cat "$candidate" >> "$output_file" 2>&1
       echo "Mock file created from POST query (maritimes CSV): $output_file" >&2
       return 0
     else
       echo "ERROR: Maritimes fixture not found: $candidate" >&2
     fi
   fi
   
   # Also check for JSON queries (for individual boundary downloads)
   if [[ "$query_content" == *"out:json"* ]] && [[ "$query_content" == *"admin_level"*"2"* ]] && [[ "$query_content" == *"boundary"*"administrative"* ]]; then
     # This is a JSON query for countries list (not individual)
     # But we'll handle it as CSV since that's what the code expects
     candidate="${fixtures_dir}/countries"
     if [[ -f "$candidate" ]]; then
       echo "@id" > "$output_file"
       cat "$candidate" >> "$output_file"
       echo "Mock file created from POST query (countries JSON->CSV): $output_file"
       return 0
     fi
   fi
   
   if [[ "$query_content" == *"out:json"* ]] && [[ "$query_content" == *"maritime"* ]]; then
     candidate="${fixtures_dir}/maritimes"
     if [[ -f "$candidate" ]]; then
       echo "@id" > "$output_file"
       cat "$candidate" >> "$output_file"
       echo "Mock file created from POST query (maritimes JSON->CSV): $output_file"
       return 0
     fi
   fi
 fi
 
 # Map common patterns to fixture filenames
 if [[ "$url" =~ ([0-9]+)\.json$ ]]; then
   candidate="${fixtures_dir}/${BASH_REMATCH[1]}.json"
 elif [[ "$url" == *"countries"* ]]; then
   candidate="${fixtures_dir}/countries"
 elif [[ "$url" == *"maritimes"* ]]; then
   candidate="${fixtures_dir}/maritimes"
 elif [[ "$url" == *"OSM-notes-API.xml"* ]] || [[ "$url" == *"search.xml"* ]] || [[ "$url" == *"/notes"* ]]; then
   # Use different fixture files based on MOCK_NOTES_COUNT environment variable
   # This handles both explicit OSM-notes-API.xml requests and API search.xml requests
   if [[ -n "${MOCK_NOTES_COUNT:-}" ]]; then
     case "${MOCK_NOTES_COUNT}" in
       0)
         candidate="${fixtures_dir}/OSM-notes-API-0.xml"
         ;;
       5)
         candidate="${fixtures_dir}/OSM-notes-API-5.xml"
         ;;
       20)
         candidate="${fixtures_dir}/OSM-notes-API-20.xml"
         ;;
       *)
         candidate="${fixtures_dir}/OSM-notes-API.xml"
         ;;
     esac
   else
     # Default: use the large fixture with 10,000 notes
     candidate="${fixtures_dir}/OSM-notes-API.xml"
   fi
 elif [[ "$url" == *"apiCall_1.xml"* ]]; then
   candidate="${fixtures_dir}/apiCall_1.xml"
 elif [[ "$url" == *"mockPlanetDump.osn.xml"* ]]; then
   candidate="${fixtures_dir}/mockPlanetDump.osn.xml"
 fi
 
 if [[ -n "$candidate" && -f "$candidate" ]]; then
   cp -f "$candidate" "$output_file"
   echo "Mock file created: $output_file"
   return 0
 fi
 
 # Create mock content based on URL
 # IMPORTANT: Check .md5 FIRST before other patterns to avoid conflicts
 if [[ "$url" == *".md5" ]]; then
   # When downloading an MD5 file, calculate the MD5 of the related file
   # The related file should be in the same directory without the .md5 extension
   local related_file
   related_file="${output_file%.md5}"
   
   # Check if the related file exists
   if [[ -f "$related_file" ]]; then
     # Calculate MD5 of the related file
     local md5_checksum
     if command -v md5sum > /dev/null 2>&1; then
       md5_checksum=$(md5sum < "$related_file" | cut -d ' ' -f 1)
     elif command -v md5 > /dev/null 2>&1; then
       md5_checksum=$(md5 -q < "$related_file")
     else
       # Fallback to fixed checksum if md5 command is not available
       md5_checksum="d41d8cd98f00b204e9800998ecf8427e"
     fi
     echo "$md5_checksum" > "$output_file"
   else
     # If related file doesn't exist, use default checksum
     echo "d41d8cd98f00b204e9800998ecf8427e" > "$output_file"
   fi
 elif [[ "$url" == *".bz2" ]]; then
   # Create a small bzip2 file
   echo "Mock bzip2 content" | bzip2 > "$output_file" 2>/dev/null || echo "Mock bzip2 content" > "$output_file"
 elif [[ "$url" == *".xml"* ]] || [[ "$url" == *"/notes"* ]] || [[ "$url" == *"search.xml"* ]]; then
   # Check for XML URLs (including those with query parameters like search.xml?limit=...)
   # First try to use fixture file if available
   if [[ -n "${candidate:-}" ]] && [[ -f "$candidate" ]]; then
     # Use fixture file (already copied above)
     : # Do nothing, file already copied
   else
     # Fallback: Generate minimal XML only if fixture not found
     # Use IDs greater than 6 million to avoid conflicts with real API notes (< 5 million)
     cat > "$output_file" << 'EOF'
<?xml version="1.0" encoding="UTF-8"?>
<osm-notes>
 <note id="6000002" lat="40.7128" lon="-74.0060" created_at="2023-01-01T00:00:00Z">
  <comment action="opened" timestamp="2023-01-01T00:00:00Z" uid="12345" user="testuser">Test note</comment>
 </note>
 <note id="6000003" lat="40.7129" lon="-74.0061" created_at="2023-01-01T01:00:00Z">
  <comment action="opened" timestamp="2023-01-01T01:00:00Z" uid="12346" user="testuser2">Test note 2</comment>
 </note>
 <note id="6000004" lat="40.7130" lon="-74.0062" created_at="2023-01-01T02:00:00Z">
  <comment action="opened" timestamp="2023-01-01T02:00:00Z" uid="12347" user="testuser3">Test note 3</comment>
 </note>
</osm-notes>
EOF
   fi
 elif [[ "$url" == *".json" ]]; then
   cat > "$output_file" << 'EOF'
{
 "type": "FeatureCollection",
 "features": [
  {
   "type": "Feature",
   "properties": {"name": "Test Country"},
   "geometry": {"type": "Polygon", "coordinates": [[[0,0],[1,0],[1,1],[0,1],[0,0]]]}
  }
 ]
}
EOF
 else
   echo "Mock content for $url" > "$output_file"
 fi
 
 echo "Mock file created: $output_file"
}

# Parse arguments
ARGS=()
OUTPUT_FILE=""
QUIET=false
TIMEOUT=""
POST_FILE=""

while [[ $# -gt 0 ]]; do
 case $1 in
  -O)
   OUTPUT_FILE="$2"
   shift 2
   ;;
  -q)
   QUIET=true
   shift
   ;;
  --timeout=*)
   TIMEOUT="${1#*=}"
   shift
   ;;
  --post-file=*)
   POST_FILE="${1#*=}"
   shift
   ;;
  --post-file)
   # Handle --post-file followed by filename as separate argument
   POST_FILE="$2"
   shift 2
   ;;
  --header=*)
   # Skip header option (User-Agent, etc.)
   shift
   ;;
  --version)
   echo "GNU Wget 1.21.3"
   exit 0
   ;;
  -*)
   # Skip other options
   shift
   ;;
  *)
   ARGS+=("$1")
   shift
   ;;
 esac
done

# Get URL from arguments
URL="${ARGS[0]:-}"

# Prevent unused variable warnings in shellcheck for supported options
: "${TIMEOUT}" "${POST_FILE}"

if [[ -z "$URL" ]]; then
 echo "Usage: wget [OPTIONS] URL" >&2
 exit 1
fi

# Create mock file
if [[ -n "$OUTPUT_FILE" ]]; then
 create_mock_file "$URL" "$OUTPUT_FILE" "$POST_FILE"
else
 create_mock_file "$URL" "" "$POST_FILE"
fi

# Simulate HTTP response
if [[ "$QUIET" != true ]]; then
 echo "HTTP/1.1 200 OK"
 echo "Content-Type: application/octet-stream"
 echo "Content-Length: $(wc -c < "${OUTPUT_FILE:-$(basename "$URL")}" 2>/dev/null || echo "0")"
 echo ""
fi

exit 0 